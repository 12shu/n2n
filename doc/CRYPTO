crypto protocol v0.0.1

Does gcrypt free() zeroize?
play through attacks

master key
==========

- two symmetric 384 bit highest quality keys
- user documentation should recommend to change it at least once a year


HMAC for handshake packets
==========================

Derive key with NIST concat KDF from master key with:
otherInfo = AlgoID || sender_SPI || receiver_SPI || MAC_SALT
sharedSecret = symmetric master key

The authentication tag will be truncated to 24 bytes (RFC 2104, 4868).

The MAC_SALT as supplementary public information will be arbitrarily chosen
as a random value 48 bytes length.

TODO: Should we really truncate the MAC tag?


Key negotiation
===============

ECDH. Look for implementations.

Diffie-Hellman secured with long term key
see key mgmt recommendations
DH support in:
- Gnutls has DH support, but only inside the TLS layer [dh algo?]
- http://cr.yp.to/ecdh.html (ecc, seems good and simple, but not NSA Suite B)
- heimdal (not yet evaluated)
- http://point-at-infinity.org/seccure/ (seems ok)
- polarssl/tropicssl (seems simple)
- gnupg/g10 secp384r1/P-384 (not accessible)


Session key derivation
======================

NIST concatenation KDF (demanded for Suite B):
OtherInfo = AlgorithmID || PartyUInfo || PartyVInfo {|| SuppPubInfo }{|| SuppPrivInfo }
Compute Hash_i = H(counter || sharedSecret || OtherInfo).
DerivedKeyingMaterial = Hash_1 || Hash_2 || ...

TODO: Should the master key really go into the KDF of the session key?

This well designed KDF could be used instead:
HMAC based key derivation function ("HKDF", RFC 5869) is specifically designed
to derive symmetric keys from negotiated shared secrets as in Diffie-Hellman.

HKDF(salt, source_key, infostring, outlen) = K1 | K2 | ... | Kt
    prk = HMAC(salt, source_key)  // (sic!)
    K1 = HMAC(prk, infostring | 0x01)
    K2 = HMAC(prk, K1 | infostring | 0x02)
    K3 = HMAC(prk, K2 | infostring | 0x03) ...

inputs: salt, source key material, infostring
- salt will be a chosen random value of length 48B
- soure key material: the DH shared secret, shall be at least 48B
- infostring will be a n2n specific constant
output: a session key


IV choice
=========

The choice of the IV is of the utmost importance, since the security of GCM
depends on NO IV being used MORE THAN ONCE with the same key.

GCM in IPsec ESP (RFC 4106):
4B salt: unpredictable but constant for SA lifetime
8B IV:   LFSR or counter [garantee uniqueness]

We choose an IV correspondingly, keep it secret until it is used and store it
with the other security association information.


Packet format
=============

We choose the encrypting and authenticating AES GCM mode for performance.

to consider:
- which fields to authenticate with GCM, but not encrypt (e.g. MAC addr)
- pad authentication data / plain text to block size?
  [according to nettle spec this is not needed, we might do it anyway on the
   plain text to make statistical analysis more difficult]
- security association explicit in packet?

planned payload AES GCM 256 bit:
?B crypto protocol version [authenticated]
12B IV
---enc---
    ?B  plaintext
	?B  padding (counting up from 1)
	1B  padding length 0-255
-enc end-
16B ICV


Security Analysis
=================

TODO

The security is based on a shared secret key, which requires that all
communicating parties trust each other.

security level NSA Suite B 192 bit:
ECDH P-384, AES GSM 256, SHA 384

Not protecting against:
- replay [TODO: consequences?; replay protection like dtls?]
- active MITM with key


References
==========

NSA Suite B
http://www.nsa.gov/ia/programs/suiteb_cryptography/

NIST Key management recommendations
http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57-Part1-revised2_Mar08-2007.pdf p. 63

The Order of Encryption and Authentication for Protecting Communications
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.106.5488&rep=rep1&type=pdf
(authenticate then encrypt vs encrypt then authenticate discussion)

GCM spec/proposal, http://www.cryptobarn.com/gcm/
http://www.cryptobarn.com/papers/gcm-spec.pdf

NIST GCM spec
http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf

Cryptolounge GCM
http://www.cryptolounge.org/wiki/GCM

HMAC: Keyed-Hashing for Message Authentication
http://tools.ietf.org/html/rfc2104

The Use of Galois/Counter Mode (GCM) in IPsec Encapsulating Security Payload (ESP)
http://tools.ietf.org/html/rfc4106

The Use of Galois Message Authentication Code (GMAC) in IPsec ESP and AH
http://tools.ietf.org/html/rfc4543

Suite B Cryptographic Suites for IPsec
http://tools.ietf.org/html/rfc4869

An Interface and Algorithms for Authenticated Encryption
http://tools.ietf.org/html/rfc5116

The Transport Layer Security (TLS) Protocol Version 1.2
http://tools.ietf.org/html/rfc5246   Section 6.2.3.2

AES Galois Counter Mode for the Secure Shell Transport Layer Protocol
http://tools.ietf.org/html/rfc5647

On Extract-then-Expand Key Derivation Functions and an HMAC-based KDF (HKDF)
http://webee.technion.ac.il/~hugo/kdf/
http://tools.ietf.org/html/rfc5869

US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)
http://tools.ietf.org/html/rfc6234
